# æ™ºèƒ½å®¶å±…é¡¹ç›® - åœ°æš–æ’æ¸©æ§åˆ¶ç³»ç»Ÿ

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

æœ¬é¡¹ç›®æ—¨åœ¨æ„å»ºä¸€ä¸ªåŸºäº ESP8266 çš„æ™ºèƒ½åœ°æš–æ’æ¸©æ§åˆ¶ç³»ç»Ÿï¼Œæ”¯æŒè¿œç¨‹æ§åˆ¶ã€æ¸©åº¦ç›‘æµ‹ã€å®šæ—¶è°ƒèŠ‚ç­‰åŠŸèƒ½ã€‚ç³»ç»Ÿå¯é€šè¿‡æ‰‹æœº Appã€Web ç•Œé¢æˆ–è¯­éŸ³åŠ©æ‰‹è¿›è¡Œæ§åˆ¶ã€‚

### ğŸ¯ ä¸»è¦åŠŸèƒ½
- ğŸŒ¡ï¸ å®æ—¶æ¸©åº¦ç›‘æµ‹å’Œæ˜¾ç¤º
- ğŸ”„ è‡ªåŠ¨æ’æ¸©æ§åˆ¶
- ğŸ“± æ‰‹æœº App è¿œç¨‹æ§åˆ¶
- ğŸŒ Web ç•Œé¢ç®¡ç†
- â° å®šæ—¶å¼€å…³å’Œæ¸©åº¦è°ƒèŠ‚
- ğŸ“Š å†å²æ•°æ®è®°å½•å’Œåˆ†æ
- ğŸ”” å¼‚å¸¸æŠ¥è­¦é€šçŸ¥
- ğŸ™ï¸ è¯­éŸ³æ§åˆ¶æ”¯æŒï¼ˆå¯é€‰ï¼‰

## ğŸ”§ ç¡¬ä»¶æ¸…å•

### æ ¸å¿ƒæ§åˆ¶å™¨
- **ESP8266** ï¼ˆå®‰ä¿¡å¯ NodeMCU/Wemos D1 Miniï¼‰
  - WiFi è¿æ¥åŠŸèƒ½
  - GPIO æ¥å£ä¸°å¯Œ
  - æ”¯æŒ Arduino IDE ç¼–ç¨‹

### é€šä¿¡æ¨¡å—
- **[433MHz æ— çº¿æ”¶å‘æ¨¡å—](https://detail.1688.com/offer/703849565767.html)**
  - å‹å·ï¼šMG100A
  - ç”¨é€”ï¼šä¸ç°æœ‰åœ°æš–æ§åˆ¶å™¨é€šä¿¡
  - é¢‘ç‡ï¼š433MHz/315MHz å¯é€‰

### ç”µæºæ¨¡å—
- **[AC-DC å¼€å…³ç”µæºæ¨¡å—](https://detail.1688.com/offer/730896565389.html)**
  - è¾“å…¥ï¼šAC 220V
  - è¾“å‡ºï¼š12V 300mA / 5V 700mA
  - åŠŸç‡ï¼š3.5W
  - ç‰¹ç‚¹ï¼šéš”ç¦»å®‰å…¨ï¼Œä½“ç§¯å°å·§

### æ§åˆ¶å™¨ä»¶
- **ç»§ç”µå™¨æ¨¡å—**
  - è§„æ ¼ï¼š5V å•è·¯/åŒè·¯ç»§ç”µå™¨
  - ç”¨é€”ï¼šæ§åˆ¶åœ°æš–é˜€é—¨æˆ–åŠ çƒ­å™¨
  - è§¦ç‚¹å®¹é‡ï¼š10A 250VAC

### ä¼ æ„Ÿå™¨æ¨¡å—
- **æ¸©åº¦ä¼ æ„Ÿå™¨**
  - DS18B20 æ•°å­—æ¸©åº¦ä¼ æ„Ÿå™¨ï¼ˆé˜²æ°´å‹ï¼‰
  - DHT22 æ¸©æ¹¿åº¦ä¼ æ„Ÿå™¨
  - ç²¾åº¦ï¼šÂ±0.5Â°C
  - å·¥ä½œèŒƒå›´ï¼š-55Â°C ~ +125Â°C

### æ˜¾ç¤ºæ¨¡å—ï¼ˆå¯é€‰ï¼‰
- **OLED æ˜¾ç¤ºå±**
  - å‹å·ï¼š0.96å¯¸ SSD1306
  - åˆ†è¾¨ç‡ï¼š128x64
  - ç”¨é€”ï¼šæœ¬åœ°æ˜¾ç¤ºæ¸©åº¦å’ŒçŠ¶æ€

### æ‰©å±•ç¡¬ä»¶
- **èœ‚é¸£å™¨**ï¼šçŠ¶æ€æç¤ºéŸ³
- **LED æŒ‡ç¤ºç¯**ï¼šå·¥ä½œçŠ¶æ€æ˜¾ç¤º
- **æŒ‰é”®å¼€å…³**ï¼šæ‰‹åŠ¨æ§åˆ¶
- **å¤–å£³**ï¼šé˜²æŠ¤ç›’ï¼Œæ¨è IP65 é˜²æŠ¤ç­‰çº§

## ğŸ“ ç³»ç»Ÿæ¶æ„

```mermaid
graph TB
    A[æ‰‹æœºApp] --> B[äº‘æœåŠ¡å™¨]
    C[Webç•Œé¢] --> B
    B --> D[WiFiç½‘ç»œ]
    D --> E[ESP8266ä¸»æ§]
    E --> F[æ¸©åº¦ä¼ æ„Ÿå™¨]
    E --> G[433MHzæ¨¡å—]
    E --> H[ç»§ç”µå™¨]
    E --> I[OLEDæ˜¾ç¤º]
    G --> J[åœ°æš–æ§åˆ¶å™¨]
    H --> K[ç”µç£é˜€/åŠ çƒ­å™¨]
    F --> L[ç¯å¢ƒæ¸©åº¦æ£€æµ‹]
```

### å·¥ä½œåŸç†
1. **æ¸©åº¦é‡‡é›†**ï¼šDS18B20 ä¼ æ„Ÿå™¨å®æ—¶ç›‘æµ‹å®¤å†…æ¸©åº¦
2. **æ•°æ®å¤„ç†**ï¼šESP8266 å¤„ç†æ¸©åº¦æ•°æ®å¹¶æ‰§è¡Œæ§åˆ¶é€»è¾‘
3. **è¿œç¨‹é€šä¿¡**ï¼šé€šè¿‡ WiFi è¿æ¥äº‘æœåŠ¡å™¨ï¼Œæ”¯æŒè¿œç¨‹æ§åˆ¶
4. **æœ¬åœ°æ§åˆ¶**ï¼š433MHz æ¨¡å—ä¸åœ°æš–æ§åˆ¶å™¨é€šä¿¡
5. **æ‰§è¡Œæ§åˆ¶**ï¼šç»§ç”µå™¨æ§åˆ¶åœ°æš–ç³»ç»Ÿå¼€å…³

## ğŸ”Œ ç¡¬ä»¶è¿æ¥å›¾

### ESP8266 å¼•è„šåˆ†é…
```
ESP8266 (NodeMCU)     è¿æ¥è®¾å¤‡
GPIO0  (D3)    -->    æŒ‰é”®å¼€å…³
GPIO2  (D4)    -->    ç»§ç”µå™¨æ§åˆ¶
GPIO4  (D2)    -->    DS18B20 æ•°æ®çº¿
GPIO5  (D1)    -->    OLED SCL
GPIO12 (D6)    -->    433MHz å‘å°„æ¨¡å—
GPIO13 (D7)    -->    433MHz æ¥æ”¶æ¨¡å—
GPIO14 (D5)    -->    OLED SDA
GPIO16 (D0)    -->    LED çŠ¶æ€æŒ‡ç¤º
3.3V           -->    ä¼ æ„Ÿå™¨ç”µæº
GND            -->    å…¬å…±åœ°çº¿
```

### ç”µæºè¿æ¥
```
220V AC è¾“å…¥ --> AC-DCæ¨¡å— --> 5Vè¾“å‡º --> ESP8266
                           --> 12Vè¾“å‡º --> ç»§ç”µå™¨æ¨¡å—
```

## ğŸ’» è½¯ä»¶æ¶æ„

### 1. å›ºä»¶å¼€å‘ (Arduino IDE)

**ä¸»è¦åº“æ–‡ä»¶ï¼š**
```cpp
#include <ESP8266WiFi.h>          // WiFi è¿æ¥
#include <WiFiClient.h>           // WiFi å®¢æˆ·ç«¯
#include <ESP8266WebServer.h>     // Web æœåŠ¡å™¨
#include <OneWire.h>              // DS18B20 é€šä¿¡
#include <DallasTemperature.h>    // æ¸©åº¦ä¼ æ„Ÿå™¨
#include <ArduinoJson.h>          // JSON æ•°æ®å¤„ç†
#include <PubSubClient.h>         // MQTT é€šä¿¡
#include <SSD1306Wire.h>          // OLED æ˜¾ç¤º
#include <RCSwitch.h>             // 433MHz é€šä¿¡
```

**æ ¸å¿ƒåŠŸèƒ½æ¨¡å—ï¼š**
```cpp
// æ¸©åº¦æ§åˆ¶ç±»
class TemperatureController {
private:
    float targetTemp;      // ç›®æ ‡æ¸©åº¦
    float currentTemp;     // å½“å‰æ¸©åº¦
    float tolerance;       // æ¸©åº¦å®¹å·®
    bool heatingStatus;    // åŠ çƒ­çŠ¶æ€
    
public:
    void setTargetTemp(float temp);
    void updateCurrentTemp();
    void controlHeating();
    bool getHeatingStatus();
};

// WiFi ç®¡ç†ç±»
class WiFiManager {
private:
    String ssid;
    String password;
    
public:
    bool connect();
    void handleReconnect();
    String getStatus();
};

// è¿œç¨‹æ§åˆ¶ç±»
class RemoteControl {
private:
    WiFiClient wifiClient;
    PubSubClient mqttClient;
    String deviceId;
    unsigned long lastHeartbeat;
    bool mqttConnected;
    
public:
    RemoteControl(String id);
    void initMQTT();
    void handleCommands();
    void sendStatus();
    void sendHeartbeat();
    void reconnectMQTT();
    bool isConnected();
    void publishTemperature(float temp);
    void publishAlert(String alertType, String message);
};

// OLEDæ˜¾ç¤ºç®¡ç†ç±»
class DisplayManager {
private:
    SSD1306Wire* display;
    bool displayEnabled;
    unsigned long lastUpdate;
    int currentPage;
    
public:
    DisplayManager(int sda, int scl);
    void init();
    void updateDisplay(float currentTemp, float targetTemp, bool heating, bool connected);
    void showWiFiConnecting();
    void showError(String error);
    void nextPage();
    void setBrightness(int level);
};

// 433MHzé€šä¿¡ç®¡ç†ç±»
class RF433Manager {
private:
    RCSwitch transmitter;
    RCSwitch receiver;
    int txPin;
    int rxPin;
    unsigned long lastSignal;
    
public:
    RF433Manager(int tx, int rx);
    void init();
    void sendCommand(unsigned long code);
    bool receiveCommand(unsigned long& code);
    void sendHeatingOn();
    void sendHeatingOff();
    bool isSignalValid(unsigned long code);
};

// å®‰å…¨ç›‘æ§ç±»
class SecurityMonitor {
private:
    float maxTemp;
    float minTemp;
    unsigned long maxHeatingTime;
    unsigned long heatingStartTime;
    bool overheating;
    bool sensorError;
    
public:
    SecurityMonitor();
    void checkTemperatureLimits(float temp);
    void checkHeatingDuration(bool heating);
    void checkSensorHealth(float temp);
    bool hasAlerts();
    String getAlertMessage();
    void resetAlerts();
};

// é…ç½®ç®¡ç†ç±»
class ConfigManager {
private:
    float defaultTargetTemp;
    float tempTolerance;
    int updateInterval;
    String wifiSSID;
    String wifiPassword;
    String mqttServer;
    
public:
    ConfigManager();
    void loadFromEEPROM();
    void saveToEEPROM();
    void setWiFiCredentials(String ssid, String password);
    void setMQTTServer(String server);
    void setTemperatureSettings(float target, float tolerance);
    float getDefaultTargetTemp();
    float getTempTolerance();
    int getUpdateInterval();
};
```

### 2. Web æœåŠ¡ç«¯ (Node.js)

**æŠ€æœ¯æ ˆï¼š**
- **åç«¯æ¡†æ¶**ï¼šExpress.js
- **æ•°æ®åº“**ï¼šMySQL / MongoDB
- **å®æ—¶é€šä¿¡**ï¼šSocket.io / MQTT
- **å‰ç«¯æ¡†æ¶**ï¼šVue.js / React

**API æ¥å£è®¾è®¡ï¼š**
```javascript
// è®¾å¤‡æ§åˆ¶ API
app.post('/api/device/control', (req, res) => {
  // è®¾ç½®ç›®æ ‡æ¸©åº¦
});

app.get('/api/device/status', (req, res) => {
  // è·å–è®¾å¤‡çŠ¶æ€
});

app.get('/api/temperature/history', (req, res) => {
  // è·å–å†å²æ¸©åº¦æ•°æ®
});

app.post('/api/schedule/set', (req, res) => {
  // è®¾ç½®å®šæ—¶ä»»åŠ¡
});
```

### 3. ç§»åŠ¨ç«¯ App

**å¼€å‘é€‰æ‹©ï¼š**
- **è·¨å¹³å°**ï¼šFlutter / React Native
- **åŸç”Ÿå¼€å‘**ï¼šAndroid Studio / Xcode
- **æ··åˆå¼€å‘**ï¼šIonic / Cordova

**ä¸»è¦é¡µé¢ï¼š**
```
â”œâ”€â”€ é¦–é¡µ
â”‚   â”œâ”€â”€ å½“å‰æ¸©åº¦æ˜¾ç¤º
â”‚   â”œâ”€â”€ ç›®æ ‡æ¸©åº¦è®¾ç½®
â”‚   â””â”€â”€ åŠ çƒ­çŠ¶æ€æŒ‡ç¤º
â”œâ”€â”€ æ§åˆ¶é¡µé¢
â”‚   â”œâ”€â”€ æ‰‹åŠ¨å¼€å…³æ§åˆ¶
â”‚   â”œâ”€â”€ æ¨¡å¼é€‰æ‹©
â”‚   â””â”€â”€ æ¸©åº¦è°ƒèŠ‚
â”œâ”€â”€ å®šæ—¶é¡µé¢
â”‚   â”œâ”€â”€ å®šæ—¶å¼€å…³è®¾ç½®
â”‚   â”œâ”€â”€ æ¸©åº¦è®¡åˆ’
â”‚   â””â”€â”€ æ˜ŸæœŸé‡å¤è®¾ç½®
â””â”€â”€ å†å²æ•°æ®
    â”œâ”€â”€ æ¸©åº¦æ›²çº¿å›¾
    â”œâ”€â”€ èƒ½è€—ç»Ÿè®¡
    â””â”€â”€ æ•°æ®å¯¼å‡º
```

## âš™ï¸ å¼€å‘ç¯å¢ƒæ­å»º

### 1. Arduino IDE é…ç½®

```bash
# å®‰è£… ESP8266 å¼€å‘æ¿æ”¯æŒåŒ…
# åœ¨ Arduino IDE ä¸­æ·»åŠ å¼€å‘æ¿ç®¡ç†å™¨ URLï¼š
# http://arduino.esp8266.com/stable/package_esp8266com_index.json

# å®‰è£…å¿…è¦çš„åº“
# å·¥å…· -> ç®¡ç†åº“ -> æœç´¢å¹¶å®‰è£…ï¼š
# - ESP8266WiFi
# - ArduinoJson
# - PubSubClient
# - OneWire
# - DallasTemperature
# - SSD1306
# - RCSwitch
```

### 2. Node.js å¼€å‘ç¯å¢ƒ

```bash
# åˆ›å»ºé¡¹ç›®ç›®å½•
mkdir smart-home-server
cd smart-home-server

# åˆå§‹åŒ–é¡¹ç›®
npm init -y

# å®‰è£…ä¾èµ–
npm install express socket.io mysql2 mqtt dotenv
npm install -D nodemon

# åˆ›å»ºé¡¹ç›®ç»“æ„
mkdir src config public
touch src/app.js config/database.js .env
```

### 3. å‰ç«¯å¼€å‘ç¯å¢ƒ

```bash
# Vue.js é¡¹ç›®
npm create vue@latest smart-home-web
cd smart-home-web
npm install

# å®‰è£… UI æ¡†æ¶
npm install element-plus
npm install echarts  # å›¾è¡¨ç»„ä»¶
```

## ğŸ“± æ ¸å¿ƒä»£ç å®ç°

### 1. ESP8266 ä¸»æ§ä»£ç 

```cpp
#include <ESP8266WiFi.h>
#include <PubSubClient.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <ArduinoJson.h>
#include <SSD1306Wire.h>
#include <RCSwitch.h>
#include <EEPROM.h>

// ç¡¬ä»¶å¼•è„šå®šä¹‰
#define TEMP_SENSOR_PIN   4    // D2 - DS18B20
#define RELAY_PIN         2    // D4 - ç»§ç”µå™¨æ§åˆ¶
#define LED_PIN          16    // D0 - LEDæŒ‡ç¤ºç¯
#define BUTTON_PIN        0    // D3 - æŒ‰é”®
#define OLED_SDA         14    // D5 - OLEDæ•°æ®çº¿
#define OLED_SCL          5    // D1 - OLEDæ—¶é’Ÿçº¿
#define RF433_TX         12    // D6 - 433MHzå‘å°„
#define RF433_RX         13    // D7 - 433MHzæ¥æ”¶
#define BUZZER_PIN       15    // D8 - èœ‚é¸£å™¨

// åˆ›å»ºä¼ æ„Ÿå™¨å®ä¾‹
OneWire oneWire(TEMP_SENSOR_PIN);
DallasTemperature tempSensor(&oneWire);

// åˆ›å»ºåŠŸèƒ½æ¨¡å—å®ä¾‹
TemperatureController tempController;
WiFiManager wifiManager;
RemoteControl* remoteControl;
DisplayManager* displayManager;
RF433Manager* rf433Manager;
SecurityMonitor securityMonitor;
ConfigManager configManager;

// å…¨å±€å˜é‡
bool manualMode = false;
unsigned long lastStatusUpdate = 0;
unsigned long lastDisplayUpdate = 0;
unsigned long lastButtonPress = 0;
bool systemReady = false;

// æŒ‰é”®çŠ¶æ€
volatile bool buttonPressed = false;
volatile unsigned long buttonPressTime = 0;

void setup() {
    Serial.begin(115200);
    Serial.println();
    Serial.println("ğŸ”¥ æ™ºèƒ½åœ°æš–æ§åˆ¶ç³»ç»Ÿå¯åŠ¨");
    Serial.println("=======================");
    
    // åˆå§‹åŒ–ç¡¬ä»¶å¼•è„š
    initializeHardware();
    
    // åŠ è½½é…ç½®
    configManager.loadFromEEPROM();
    configManager.printConfig();
    
    // åˆå§‹åŒ–ä¼ æ„Ÿå™¨
    initializeSensors();
    
    // åˆå§‹åŒ–æ˜¾ç¤ºå±
    displayManager = new DisplayManager(OLED_SDA, OLED_SCL);
    displayManager->init();
    
    // åˆå§‹åŒ–WiFi
    initializeWiFi();
    
    // åˆå§‹åŒ–MQTT
    initializeMQTT();
    
    // åˆå§‹åŒ–433MHzæ¨¡å—
    rf433Manager = new RF433Manager(RF433_TX, RF433_RX);
    rf433Manager->init();
    
    // è®¾ç½®åˆå§‹æ¸©åº¦
    tempController.setTargetTemp(configManager.getDefaultTargetTemp());
    
    // ç³»ç»Ÿå°±ç»ª
    systemReady = true;
    playStartupSound();
    
    Serial.println("âœ… ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ");
    Serial.printf("ğŸ†” è®¾å¤‡ID: %s\n", configManager.getDeviceId().c_str());
    Serial.printf("ğŸŒ¡ï¸ ç›®æ ‡æ¸©åº¦: %.1fÂ°C\n", tempController.getTargetTemp());
    
    // æ˜¾ç¤ºå°±ç»ªä¿¡æ¯
    displayManager->updateDisplay(
        tempController.getCurrentTemp(),
        tempController.getTargetTemp(),
        tempController.getHeatingStatus(),
        wifiManager.isConnected()
    );
}

void loop() {
    if(!systemReady) return;
    
    // å¤„ç†WiFiè¿æ¥
    wifiManager.handleReconnect();
    
    // å¤„ç†MQTTé€šä¿¡
    if(remoteControl) {
        remoteControl->handleCommands();
    }
    
    // è¯»å–æ¸©åº¦
    updateTemperature();
    
    // æ¸©åº¦æ§åˆ¶é€»è¾‘
    handleTemperatureControl();
    
    // å¤„ç†æŒ‰é”®
    handleButtonInput();
    
    // å¤„ç†433MHzé€šä¿¡
    handle433Communication();
    
    // å®‰å…¨ç›‘æ§
    handleSecurityMonitoring();
    
    // æ›´æ–°æ˜¾ç¤º
    updateDisplay();
    
    // å‘é€çŠ¶æ€æ•°æ®
    sendStatusUpdate();
    
    // å°å»¶æ—¶
    delay(100);
}

void initializeHardware() {
    // é…ç½®å¼•è„šæ¨¡å¼
    pinMode(RELAY_PIN, OUTPUT);
    pinMode(LED_PIN, OUTPUT);
    pinMode(BUTTON_PIN, INPUT_PULLUP);
    pinMode(BUZZER_PIN, OUTPUT);
    
    // åˆå§‹çŠ¶æ€
    digitalWrite(RELAY_PIN, LOW);
    digitalWrite(LED_PIN, LOW);
    digitalWrite(BUZZER_PIN, LOW);
    
    // é…ç½®æŒ‰é”®ä¸­æ–­
    attachInterrupt(digitalPinToInterrupt(BUTTON_PIN), buttonISR, FALLING);
    
    Serial.println("ğŸ”§ ç¡¬ä»¶åˆå§‹åŒ–å®Œæˆ");
}

void initializeSensors() {
    tempSensor.begin();
    
    // æ£€æŸ¥ä¼ æ„Ÿå™¨æ•°é‡
    int deviceCount = tempSensor.getDeviceCount();
    Serial.printf("ğŸŒ¡ï¸ å‘ç° %d ä¸ªæ¸©åº¦ä¼ æ„Ÿå™¨\n", deviceCount);
    
    if(deviceCount == 0) {
        Serial.println("âŒ æœªå‘ç°æ¸©åº¦ä¼ æ„Ÿå™¨ï¼");
        // å¯ä»¥è®¾ç½®é”™è¯¯çŠ¶æ€æˆ–ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®
    } else {
        tempSensor.setResolution(12);  // è®¾ç½®12ä½ç²¾åº¦
        Serial.println("âœ… æ¸©åº¦ä¼ æ„Ÿå™¨åˆå§‹åŒ–å®Œæˆ");
    }
}

void initializeWiFi() {
    displayManager->showWiFiConnecting();
    
    String ssid = configManager.getWiFiSSID();
    String password = configManager.getWiFiPassword();
    
    if(ssid.length() == 0) {
        // æ²¡æœ‰WiFié…ç½®ï¼Œå¯åŠ¨APæ¨¡å¼
        wifiManager.startAPMode();
        setupWebConfig();  // å¯åŠ¨Webé…ç½®é¡µé¢
    } else {
        wifiManager.setCredentials(ssid, password);
        bool connected = wifiManager.connect();
        
        if(connected) {
            digitalWrite(LED_PIN, HIGH);  // WiFiè¿æ¥æˆåŠŸæŒ‡ç¤º
        }
    }
}

void initializeMQTT() {
    if(!wifiManager.isConnected()) return;
    
    remoteControl = new RemoteControl(configManager.getDeviceId());
    remoteControl->setServer(configManager.getMQTTServer(), configManager.getMQTTPort());
    remoteControl->initMQTT();
    remoteControl->connect();
}

void updateTemperature() {
    static unsigned long lastTempRead = 0;
    unsigned long now = millis();
    
    if(now - lastTempRead > 5000) {  // 5ç§’è¯»å–ä¸€æ¬¡æ¸©åº¦
        lastTempRead = now;
        
        tempSensor.requestTemperatures();
        float temp = tempSensor.getTempCByIndex(0);
        
        if(temp != DEVICE_DISCONNECTED_C && temp > -50 && temp < 80) {
            tempController.updateCurrentTemp(temp);
            securityMonitor.checkTemperatureLimits(temp);
            securityMonitor.checkSensorHealth(temp);
        } else {
            Serial.println("âŒ æ¸©åº¦ä¼ æ„Ÿå™¨è¯»å–å¤±è´¥");
            securityMonitor.checkSensorHealth(-127.0);  // ä¼ é€’é”™è¯¯å€¼
        }
    }
}

void handleTemperatureControl() {
    if(!manualMode) {
        // è‡ªåŠ¨æ¨¡å¼
        bool statusChanged = tempController.controlHeating();
        
        if(statusChanged) {
            bool heating = tempController.getHeatingStatus();
            
            // æ§åˆ¶ç»§ç”µå™¨
            digitalWrite(RELAY_PIN, heating ? HIGH : LOW);
            
            // æ§åˆ¶433MHzè®¾å¤‡ï¼ˆå¦‚æœéœ€è¦ï¼‰
            if(heating) {
                rf433Manager->sendHeatingOn();
            } else {
                rf433Manager->sendHeatingOff();
            }
            
            // æ’­æ”¾æç¤ºéŸ³
            if(heating) {
                playBeep(2, 100);  // å¼€å¯åŠ çƒ­ï¼š2å£°çŸ­é¸£
            } else {
                playBeep(1, 200);  // å…³é—­åŠ çƒ­ï¼š1å£°é•¿é¸£
            }
        }
    }
    
    // æ›´æ–°å®‰å…¨ç›‘æ§
    securityMonitor.checkHeatingDuration(tempController.getHeatingStatus());
}

void handleButtonInput() {
    if(buttonPressed) {
        buttonPressed = false;
        unsigned long pressDuration = millis() - buttonPressTime;
        
        if(pressDuration > 50 && pressDuration < 3000) {
            // çŸ­æŒ‰ï¼šåˆ‡æ¢é¡µé¢
            displayManager->nextPage();
            playBeep(1, 50);
        } else if(pressDuration >= 3000) {
            // é•¿æŒ‰ï¼šåˆ‡æ¢æ‰‹åŠ¨/è‡ªåŠ¨æ¨¡å¼
            manualMode = !manualMode;
            Serial.printf("ğŸ”§ åˆ‡æ¢åˆ°%sæ¨¡å¼\n", manualMode ? "æ‰‹åŠ¨" : "è‡ªåŠ¨");
            
            if(manualMode) {
                playBeep(3, 100);  // æ‰‹åŠ¨æ¨¡å¼ï¼š3å£°çŸ­é¸£
            } else {
                playBeep(2, 200);  // è‡ªåŠ¨æ¨¡å¼ï¼š2å£°é•¿é¸£
            }
        }
    }
}

void handle433Communication() {
    unsigned long receivedCode;
    if(rf433Manager->receiveCommand(receivedCode)) {
        // å¤„ç†æ¥æ”¶åˆ°çš„433MHzä¿¡å·
        Serial.printf("ğŸ“¡ æ”¶åˆ°433MHzä¿¡å·: %lu\n", receivedCode);
        
        // å¯ä»¥æ ¹æ®ä¿¡å·ç æ‰§è¡Œç›¸åº”æ“ä½œ
        // ä¾‹å¦‚ï¼šæ¸©åº¦è°ƒèŠ‚ã€æ¨¡å¼åˆ‡æ¢ç­‰
    }
}

void handleSecurityMonitoring() {
    static unsigned long lastSecurityCheck = 0;
    unsigned long now = millis();
    
    if(now - lastSecurityCheck > 10000) {  // 10ç§’æ£€æŸ¥ä¸€æ¬¡
        lastSecurityCheck = now;
        
        if(securityMonitor.hasAlerts()) {
            String alertMsg = securityMonitor.getDetailedAlert();
            Serial.printf("ğŸš¨ å®‰å…¨è­¦æŠ¥: %s\n", alertMsg.c_str());
            
            // å‘é€MQTTè­¦æŠ¥
            if(remoteControl && remoteControl->isConnected()) {
                String alertType = securityMonitor.isOverheating() ? "overheat" :
                                 securityMonitor.isSensorError() ? "sensor_error" :
                                 securityMonitor.isHeatingTimeout() ? "heating_timeout" : "unknown";
                
                remoteControl->publishAlert(alertType, alertMsg);
            }
            
            // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
            displayManager->showError(securityMonitor.getAlertMessage());
            
            // æ’­æ”¾è­¦æŠ¥å£°
            playAlarm();
            
            // å¦‚æœè¿‡çƒ­ï¼Œç«‹å³å…³é—­åŠ çƒ­
            if(securityMonitor.isOverheating()) {
                digitalWrite(RELAY_PIN, LOW);
                tempController.setHeatingStatus(false);
                manualMode = true;  // åˆ‡æ¢åˆ°æ‰‹åŠ¨æ¨¡å¼é˜²æ­¢è‡ªåŠ¨é‡å¯
            }
        }
    }
}

void updateDisplay() {
    static unsigned long lastDisplayUpdate = 0;
    unsigned long now = millis();
    
    if(now - lastDisplayUpdate > 1000) {  // 1ç§’æ›´æ–°ä¸€æ¬¡æ˜¾ç¤º
        lastDisplayUpdate = now;
        
        if(!securityMonitor.hasAlerts()) {  // æ²¡æœ‰è­¦æŠ¥æ—¶æ­£å¸¸æ˜¾ç¤º
            displayManager->updateDisplay(
                tempController.getCurrentTemp(),
                tempController.getTargetTemp(),
                tempController.getHeatingStatus(),
                wifiManager.isConnected()
            );
        }
    }
}

void sendStatusUpdate() {
    static unsigned long lastStatusSend = 0;
    unsigned long now = millis();
    
    int updateInterval = configManager.getUpdateInterval() * 1000;
    if(now - lastStatusSend > updateInterval) {
        lastStatusSend = now;
        
        if(remoteControl && remoteControl->isConnected()) {
            remoteControl->sendStatus(
                tempController.getCurrentTemp(),
                tempController.getTargetTemp(),
                tempController.getHeatingStatus(),
                manualMode
            );
        }
    }
}

// ä¸­æ–­æœåŠ¡ç¨‹åº
ICACHE_RAM_ATTR void buttonISR() {
    static unsigned long lastInterrupt = 0;
    unsigned long now = millis();
    
    // é˜²æŠ–åŠ¨
    if(now - lastInterrupt > 200) {
        buttonPressed = true;
        buttonPressTime = now;
        lastInterrupt = now;
    }
}

// å£°éŸ³æç¤ºå‡½æ•°
void playBeep(int count, int duration) {
    for(int i = 0; i < count; i++) {
        digitalWrite(BUZZER_PIN, HIGH);
        delay(duration);
        digitalWrite(BUZZER_PIN, LOW);
        if(i < count - 1) delay(100);
    }
}

void playStartupSound() {
    // æ’­æ”¾å¯åŠ¨éŸ³æ•ˆ
    int melody[] = {262, 294, 330, 349};  // C, D, E, F
    for(int i = 0; i < 4; i++) {
        tone(BUZZER_PIN, melody[i], 200);
        delay(250);
    }
    noTone(BUZZER_PIN);
}

void playAlarm() {
    // æ’­æ”¾è­¦æŠ¥å£°
    for(int i = 0; i < 5; i++) {
        digitalWrite(BUZZER_PIN, HIGH);
        delay(100);
        digitalWrite(BUZZER_PIN, LOW);
        delay(100);
    }
}

// Webé…ç½®é¡µé¢ï¼ˆå½“æ²¡æœ‰WiFié…ç½®æ—¶ä½¿ç”¨ï¼‰
void setupWebConfig() {
    // è¿™é‡Œå¯ä»¥æ·»åŠ WebæœåŠ¡å™¨ä»£ç æ¥é…ç½®WiFi
    // è¯¦ç»†å®ç°å¯ä»¥ä½¿ç”¨WiFiManageråº“æˆ–è‡ªå®šä¹‰Webç•Œé¢
    Serial.println("ğŸŒ å¯åŠ¨Webé…ç½®æœåŠ¡å™¨");
    Serial.println("è¯·è¿æ¥åˆ° SmartHeater_Config ç½‘ç»œè¿›è¡Œé…ç½®");
}

// å‘½ä»¤å¤„ç†å›è°ƒï¼ˆä¾›MQTTä½¿ç”¨ï¼‰
void handleRemoteCommand(String command, JsonDocument& params) {
    if(command == "setTargetTemp") {
        float newTarget = params["value"];
        tempController.setTargetTemp(newTarget);
        Serial.printf("ğŸ¯ è¿œç¨‹è®¾ç½®ç›®æ ‡æ¸©åº¦: %.1fÂ°C\n", newTarget);
        
    } else if(command == "setMode") {
        manualMode = params["manual"];
        Serial.printf("ğŸ”§ è¿œç¨‹åˆ‡æ¢æ¨¡å¼: %s\n", manualMode ? "æ‰‹åŠ¨" : "è‡ªåŠ¨");
        
    } else if(command == "manualControl") {
        if(manualMode) {
            bool heating = params["heating"];
            digitalWrite(RELAY_PIN, heating ? HIGH : LOW);
            tempController.setHeatingStatus(heating);
            Serial.printf("ğŸ”¥ è¿œç¨‹æ‰‹åŠ¨æ§åˆ¶: %s\n", heating ? "å¼€å¯" : "å…³é—­");
        }
        
    } else if(command == "updateConfig") {
        // æ›´æ–°é…ç½®
        if(params.containsKey("targetTemp")) {
            configManager.setTemperatureSettings(params["targetTemp"], configManager.getTempTolerance());
        }
        if(params.containsKey("updateInterval")) {
            configManager.setUpdateInterval(params["updateInterval"]);
        }
        configManager.saveToEEPROM();
        Serial.println("ğŸ’¾ é…ç½®å·²æ›´æ–°");
        
    } else if(command == "resetAlerts") {
        securityMonitor.resetAlerts();
        Serial.println("ğŸ”„ è­¦æŠ¥å·²é‡ç½®");
        
    } else if(command == "reboot") {
        Serial.println("ğŸ”„ è¿œç¨‹é‡å¯");
        delay(1000);
        ESP.restart();
    }
}

// ç³»ç»ŸçŠ¶æ€æ£€æŸ¥
void checkSystemHealth() {
    // æ£€æŸ¥å †å†…å­˜
    if(ESP.getFreeHeap() < 1000) {
        Serial.println("âš ï¸ å†…å­˜ä¸è¶³è­¦å‘Š");
    }
    
    // æ£€æŸ¥WiFiè¿æ¥
    if(!wifiManager.isConnected()) {
        digitalWrite(LED_PIN, LOW);
    }
    
    // æ£€æŸ¥MQTTè¿æ¥
    if(remoteControl && !remoteControl->isConnected()) {
        Serial.println("âš ï¸ MQTTè¿æ¥ä¸¢å¤±");
    }
}
```

### 2. Node.js æœåŠ¡å™¨ä»£ç 

```javascript
// src/app.js
const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const mqtt = require('mqtt');
const mysql = require('mysql2/promise');
require('dotenv').config();

const app = express();
const server = http.createServer(app);
const io = socketIo(server, {
  cors: {
    origin: "*",
    methods: ["GET", "POST"]
  }
});

// ä¸­é—´ä»¶
app.use(express.json());
app.use(express.static('public'));

// æ•°æ®åº“è¿æ¥
const dbConfig = {
  host: process.env.DB_HOST || 'localhost',
  user: process.env.DB_USER || 'root',
  password: process.env.DB_PASSWORD || '',
  database: process.env.DB_NAME || 'smart_home'
};

// MQTT å®¢æˆ·ç«¯
const mqttClient = mqtt.connect(process.env.MQTT_BROKER || 'mqtt://localhost:1883');

// å…¨å±€çŠ¶æ€
let deviceStatus = {
  currentTemp: 0,
  targetTemp: 22,
  heatingStatus: false,
  manualMode: false,
  lastUpdate: new Date()
};

// MQTT äº‹ä»¶å¤„ç†
mqttClient.on('connect', () => {
  console.log('MQTT è¿æ¥æˆåŠŸ');
  mqttClient.subscribe('smart-home/temperature/status');
});

mqttClient.on('message', async (topic, message) => {
  try {
    const data = JSON.parse(message.toString());
    
    if (topic === 'smart-home/temperature/status') {
      deviceStatus = {
        ...data,
        lastUpdate: new Date()
      };
      
      // å¹¿æ’­çŠ¶æ€ç»™æ‰€æœ‰è¿æ¥çš„å®¢æˆ·ç«¯
      io.emit('deviceStatus', deviceStatus);
      
      // ä¿å­˜åˆ°æ•°æ®åº“
      await saveTemperatureData(data);
    }
  } catch (error) {
    console.error('MQTT æ¶ˆæ¯å¤„ç†é”™è¯¯:', error);
  }
});

// Socket.io è¿æ¥å¤„ç†
io.on('connection', (socket) => {
  console.log('å®¢æˆ·ç«¯è¿æ¥:', socket.id);
  
  // å‘é€å½“å‰çŠ¶æ€
  socket.emit('deviceStatus', deviceStatus);
  
  // å¤„ç†æ¸©åº¦è®¾ç½®
  socket.on('setTargetTemp', (targetTemp) => {
    const command = { targetTemp: parseFloat(targetTemp) };
    mqttClient.publish('smart-home/temperature/control', JSON.stringify(command));
    console.log('è®¾ç½®ç›®æ ‡æ¸©åº¦:', targetTemp);
  });
  
  // å¤„ç†æ¨¡å¼åˆ‡æ¢
  socket.on('setMode', (manualMode) => {
    const command = { manualMode: Boolean(manualMode) };
    mqttClient.publish('smart-home/temperature/control', JSON.stringify(command));
    console.log('è®¾ç½®æ¨¡å¼:', manualMode ? 'æ‰‹åŠ¨' : 'è‡ªåŠ¨');
  });
  
  // å¤„ç†æ‰‹åŠ¨æ§åˆ¶
  socket.on('manualControl', (heating) => {
    const command = { heating: Boolean(heating), manualMode: true };
    mqttClient.publish('smart-home/temperature/control', JSON.stringify(command));
    console.log('æ‰‹åŠ¨æ§åˆ¶åŠ çƒ­:', heating ? 'å¼€å¯' : 'å…³é—­');
  });
  
  socket.on('disconnect', () => {
    console.log('å®¢æˆ·ç«¯æ–­å¼€:', socket.id);
  });
});

// REST API è·¯ç”±
app.get('/api/status', (req, res) => {
  res.json(deviceStatus);
});

app.post('/api/control', (req, res) => {
  const { targetTemp, manualMode, heating } = req.body;
  
  const command = {};
  if (targetTemp !== undefined) command.targetTemp = parseFloat(targetTemp);
  if (manualMode !== undefined) command.manualMode = Boolean(manualMode);
  if (heating !== undefined) command.heating = Boolean(heating);
  
  mqttClient.publish('smart-home/temperature/control', JSON.stringify(command));
  
  res.json({ success: true, message: 'å‘½ä»¤å·²å‘é€' });
});

app.get('/api/history', async (req, res) => {
  try {
    const { startDate, endDate, limit = 100 } = req.query;
    
    const connection = await mysql.createConnection(dbConfig);
    
    let query = 'SELECT * FROM temperature_logs';
    let params = [];
    
    if (startDate && endDate) {
      query += ' WHERE timestamp BETWEEN ? AND ?';
      params = [startDate, endDate];
    }
    
    query += ' ORDER BY timestamp DESC LIMIT ?';
    params.push(parseInt(limit));
    
    const [rows] = await connection.execute(query, params);
    await connection.end();
    
    res.json(rows);
  } catch (error) {
    console.error('æŸ¥è¯¢å†å²æ•°æ®é”™è¯¯:', error);
    res.status(500).json({ error: 'æŸ¥è¯¢å¤±è´¥' });
  }
});

// å®šæ—¶ä»»åŠ¡ç›¸å…³ API
app.get('/api/schedules', async (req, res) => {
  try {
    const connection = await mysql.createConnection(dbConfig);
    const [rows] = await connection.execute('SELECT * FROM schedules WHERE enabled = 1');
    await connection.end();
    res.json(rows);
  } catch (error) {
    res.status(500).json({ error: 'æŸ¥è¯¢å®šæ—¶ä»»åŠ¡å¤±è´¥' });
  }
});

app.post('/api/schedules', async (req, res) => {
  try {
    const { name, time, targetTemp, weekdays, enabled = true } = req.body;
    
    const connection = await mysql.createConnection(dbConfig);
    const [result] = await connection.execute(
      'INSERT INTO schedules (name, time, target_temp, weekdays, enabled) VALUES (?, ?, ?, ?, ?)',
      [name, time, targetTemp, JSON.stringify(weekdays), enabled]
    );
    await connection.end();
    
    res.json({ success: true, id: result.insertId });
  } catch (error) {
    res.status(500).json({ error: 'åˆ›å»ºå®šæ—¶ä»»åŠ¡å¤±è´¥' });
  }
});

// æ•°æ®åº“æ“ä½œå‡½æ•°
async function saveTemperatureData(data) {
  try {
    const connection = await mysql.createConnection(dbConfig);
    await connection.execute(
      'INSERT INTO temperature_logs (current_temp, target_temp, heating_status, timestamp) VALUES (?, ?, ?, NOW())',
      [data.currentTemp, data.targetTemp, data.heatingStatus]
    );
    await connection.end();
  } catch (error) {
    console.error('ä¿å­˜æ¸©åº¦æ•°æ®é”™è¯¯:', error);
  }
}

// å®šæ—¶ä»»åŠ¡å¤„ç†
function checkSchedules() {
  // æ£€æŸ¥å¹¶æ‰§è¡Œå®šæ—¶ä»»åŠ¡çš„é€»è¾‘
  // è¿™é‡Œå¯ä»¥æ·»åŠ  cron ä»»åŠ¡æ¥å®šæœŸæ£€æŸ¥
}

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`æ™ºèƒ½å®¶å±…æœåŠ¡å™¨è¿è¡Œåœ¨ç«¯å£ ${PORT}`);
});
```

### 3. æ•°æ®åº“ç»“æ„

```sql
-- åˆ›å»ºæ•°æ®åº“
CREATE DATABASE smart_home CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
USE smart_home;

-- æ¸©åº¦æ—¥å¿—è¡¨
CREATE TABLE temperature_logs (
    id INT AUTO_INCREMENT PRIMARY KEY,
    current_temp DECIMAL(5,2) NOT NULL COMMENT 'å½“å‰æ¸©åº¦',
    target_temp DECIMAL(5,2) NOT NULL COMMENT 'ç›®æ ‡æ¸©åº¦',
    heating_status BOOLEAN NOT NULL DEFAULT FALSE COMMENT 'åŠ çƒ­çŠ¶æ€',
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT 'è®°å½•æ—¶é—´',
    INDEX idx_timestamp (timestamp)
) COMMENT='æ¸©åº¦ç›‘æ§æ—¥å¿—';

-- å®šæ—¶ä»»åŠ¡è¡¨
CREATE TABLE schedules (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL COMMENT 'ä»»åŠ¡åç§°',
    time TIME NOT NULL COMMENT 'æ‰§è¡Œæ—¶é—´',
    target_temp DECIMAL(5,2) NOT NULL COMMENT 'ç›®æ ‡æ¸©åº¦',
    weekdays JSON NOT NULL COMMENT 'æ‰§è¡Œæ˜ŸæœŸ',
    enabled BOOLEAN DEFAULT TRUE COMMENT 'æ˜¯å¦å¯ç”¨',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) COMMENT='å®šæ—¶ä»»åŠ¡';

-- è®¾å¤‡é…ç½®è¡¨
CREATE TABLE device_config (
    id INT AUTO_INCREMENT PRIMARY KEY,
    config_key VARCHAR(50) NOT NULL UNIQUE,
    config_value TEXT NOT NULL,
    description VARCHAR(200),
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) COMMENT='è®¾å¤‡é…ç½®';

-- æ’å…¥é»˜è®¤é…ç½®
INSERT INTO device_config (config_key, config_value, description) VALUES 
('default_target_temp', '22.0', 'é»˜è®¤ç›®æ ‡æ¸©åº¦'),
('temp_tolerance', '0.5', 'æ¸©åº¦æ§åˆ¶å®¹å·®'),
('heating_max_duration', '120', 'æœ€å¤§è¿ç»­åŠ çƒ­æ—¶é—´(åˆ†é’Ÿ)'),
('temp_update_interval', '30', 'æ¸©åº¦æ›´æ–°é—´éš”(ç§’)');

-- æŠ¥è­¦æ—¥å¿—è¡¨
CREATE TABLE alarm_logs (
    id INT AUTO_INCREMENT PRIMARY KEY,
    alarm_type ENUM('high_temp', 'low_temp', 'sensor_error', 'connection_lost') NOT NULL,
    message TEXT NOT NULL,
    current_temp DECIMAL(5,2),
    resolved BOOLEAN DEFAULT FALSE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    resolved_at DATETIME NULL
) COMMENT='æŠ¥è­¦æ—¥å¿—';
```

### 4. å®Œæ•´çš„ç±»å®ç°

```cpp
// ========================= TemperatureController å®ç° =========================
class TemperatureController {
private:
    float targetTemp;
    float currentTemp;
    float tolerance;
    bool heatingStatus;
    unsigned long lastTempRead;
    float tempHistory[10];  // æ¸©åº¦å†å²è®°å½•
    int historyIndex;
    
public:
    TemperatureController() {
        targetTemp = 22.0;
        currentTemp = 0.0;
        tolerance = 0.5;
        heatingStatus = false;
        lastTempRead = 0;
        historyIndex = 0;
        
        // åˆå§‹åŒ–æ¸©åº¦å†å²
        for(int i = 0; i < 10; i++) {
            tempHistory[i] = 0.0;
        }
    }
    
    void setTargetTemp(float temp) {
        if(temp >= 5.0 && temp <= 35.0) {
            targetTemp = temp;
            Serial.printf("ç›®æ ‡æ¸©åº¦è®¾ç½®ä¸º: %.1fÂ°C\n", targetTemp);
        }
    }
    
    float getTargetTemp() {
        return targetTemp;
    }
    
    void updateCurrentTemp(float temp) {
        if(temp > -50.0 && temp < 80.0) {  // åˆç†æ¸©åº¦èŒƒå›´æ£€æŸ¥
            currentTemp = temp;
            
            // æ›´æ–°æ¸©åº¦å†å²
            tempHistory[historyIndex] = temp;
            historyIndex = (historyIndex + 1) % 10;
            
            lastTempRead = millis();
        }
    }
    
    float getCurrentTemp() {
        return currentTemp;
    }
    
    bool controlHeating() {
        bool shouldHeat = currentTemp < (targetTemp - tolerance);
        bool shouldStop = currentTemp > (targetTemp + tolerance);
        
        if(shouldHeat && !heatingStatus) {
            heatingStatus = true;
            Serial.println("ğŸ”¥ å¼€å¯åŠ çƒ­");
            return true;  // çŠ¶æ€æ”¹å˜
        } else if(shouldStop && heatingStatus) {
            heatingStatus = false;
            Serial.println("â„ï¸ å…³é—­åŠ çƒ­");
            return true;  // çŠ¶æ€æ”¹å˜
        }
        
        return false;  // çŠ¶æ€æœªæ”¹å˜
    }
    
    bool getHeatingStatus() {
        return heatingStatus;
    }
    
    void setHeatingStatus(bool status) {
        heatingStatus = status;
    }
    
    float getAverageTemp() {
        float sum = 0;
        int count = 0;
        for(int i = 0; i < 10; i++) {
            if(tempHistory[i] != 0.0) {
                sum += tempHistory[i];
                count++;
            }
        }
        return count > 0 ? sum / count : currentTemp;
    }
    
    bool isTempStable() {
        // æ£€æŸ¥æ¸©åº¦æ˜¯å¦ç¨³å®šï¼ˆå˜åŒ–å°äº0.2åº¦ï¼‰
        float max = tempHistory[0];
        float min = tempHistory[0];
        
        for(int i = 1; i < 10; i++) {
            if(tempHistory[i] != 0.0) {
                if(tempHistory[i] > max) max = tempHistory[i];
                if(tempHistory[i] < min) min = tempHistory[i];
            }
        }
        
        return (max - min) < 0.2;
    }
};

// ========================= WiFiManager å®ç° =========================
class WiFiManager {
private:
    String ssid;
    String password;
    unsigned long lastReconnectAttempt;
    int reconnectInterval;
    bool apMode;
    
public:
    WiFiManager() {
        lastReconnectAttempt = 0;
        reconnectInterval = 30000;  // 30ç§’é‡è¿é—´éš”
        apMode = false;
    }
    
    void setCredentials(String s, String p) {
        ssid = s;
        password = p;
    }
    
    bool connect() {
        WiFi.mode(WIFI_STA);
        WiFi.begin(ssid.c_str(), password.c_str());
        
        Serial.printf("æ­£åœ¨è¿æ¥åˆ° WiFi: %s", ssid.c_str());
        
        int attempts = 0;
        while(WiFi.status() != WL_CONNECTED && attempts < 20) {
            delay(500);
            Serial.print(".");
            attempts++;
        }
        
        if(WiFi.status() == WL_CONNECTED) {
            Serial.println();
            Serial.print("WiFi è¿æ¥æˆåŠŸï¼IP åœ°å€: ");
            Serial.println(WiFi.localIP());
            
            // WiFi è¿æ¥æˆåŠŸæŒ‡ç¤º
            digitalWrite(LED_PIN, HIGH);
            apMode = false;
            return true;
        } else {
            Serial.println();
            Serial.println("âŒ WiFiè¿æ¥å¤±è´¥ï¼Œå¯åŠ¨APæ¨¡å¼");
            startAPMode();
            return false;
        }
    }
    
    void startAPMode() {
        WiFi.mode(WIFI_AP);
        WiFi.softAP("SmartHeater_Config", "12345678");
        
        Serial.printf("ğŸ”¥ APæ¨¡å¼å·²å¯åŠ¨\n");
        Serial.printf("ğŸ“¡ AP IP: %s\n", WiFi.softAPIP().toString().c_str());
        Serial.println("ğŸŒ è¯·è¿æ¥åˆ° 'SmartHeater_Config' è¿›è¡Œé…ç½®");
        
        apMode = true;
    }
    
    void handleReconnect() {
        if(WiFi.status() != WL_CONNECTED && !apMode) {
            unsigned long now = millis();
            if(now - lastReconnectAttempt > reconnectInterval) {
                lastReconnectAttempt = now;
                Serial.println("ğŸ”„ å°è¯•é‡æ–°è¿æ¥WiFi...");
                
                if(!connect()) {
                    reconnectInterval = min(reconnectInterval * 2, 300000);  // æœ€å¤§5åˆ†é’Ÿ
                } else {
                    reconnectInterval = 30000;  // é‡ç½®ä¸º30ç§’
                }
            }
        }
    }
    
    String getStatus() {
        if(apMode) {
            return "APæ¨¡å¼";
        } else if(WiFi.status() == WL_CONNECTED) {
            return "å·²è¿æ¥ - " + WiFi.localIP().toString();
        } else {
            return "æœªè¿æ¥";
        }
    }
    
    int getSignalStrength() {
        return WiFi.RSSI();
    }
    
    bool isConnected() {
        return WiFi.status() == WL_CONNECTED && !apMode;
    }
    
    bool isAPMode() {
        return apMode;
    }
};

// ========================= RemoteControl å®ç° =========================
class RemoteControl {
private:
    WiFiClient wifiClient;
    PubSubClient mqttClient;
    String deviceId;
    String mqttServer;
    int mqttPort;
    unsigned long lastHeartbeat;
    unsigned long lastReconnectAttempt;
    bool mqttConnected;
    
public:
    RemoteControl(String id) : mqttClient(wifiClient) {
        deviceId = id;
        mqttServer = "your-mqtt-server.com";
        mqttPort = 1883;
        lastHeartbeat = 0;
        lastReconnectAttempt = 0;
        mqttConnected = false;
    }
    
    void initMQTT() {
        mqttClient.setServer(mqttServer.c_str(), mqttPort);
        mqttClient.setCallback([this](char* topic, byte* payload, unsigned int length) {
            this->onMqttMessage(topic, payload, length);
        });
        
        mqttClient.setKeepAlive(60);
        mqttClient.setSocketTimeout(30);
        
        Serial.println("ğŸ“¡ MQTTå®¢æˆ·ç«¯å·²åˆå§‹åŒ–");
    }
    
    void setServer(String server, int port) {
        mqttServer = server;
        mqttPort = port;
        mqttClient.setServer(server.c_str(), port);
    }
    
    bool connect() {
        if(!WiFi.isConnected()) {
            return false;
        }
        
        String clientId = "SmartHeater_" + deviceId + "_" + String(random(0xffff), HEX);
        
        Serial.printf("ğŸ”Œ å°è¯•è¿æ¥MQTT: %s:%d\n", mqttServer.c_str(), mqttPort);
        
        if(mqttClient.connect(clientId.c_str())) {
            mqttConnected = true;
            Serial.println("âœ… MQTTè¿æ¥æˆåŠŸ");
            
            // è®¢é˜…æ§åˆ¶ä¸»é¢˜
            String controlTopic = "smart-home/" + deviceId + "/control";
            mqttClient.subscribe(controlTopic.c_str());
            Serial.printf("ğŸ“¨ å·²è®¢é˜…: %s\n", controlTopic.c_str());
            
            // å‘é€ä¸Šçº¿æ¶ˆæ¯
            publishOnlineStatus(true);
            
            return true;
        } else {
            mqttConnected = false;
            Serial.printf("âŒ MQTTè¿æ¥å¤±è´¥, é”™è¯¯ç : %d\n", mqttClient.state());
            return false;
        }
    }
    
    void handleCommands() {
        if(mqttConnected) {
            mqttClient.loop();
        } else {
            reconnectMQTT();
        }
        
        // å‘é€å¿ƒè·³
        sendHeartbeat();
    }
    
    void reconnectMQTT() {
        unsigned long now = millis();
        if(now - lastReconnectAttempt > 5000) {  // 5ç§’é‡è¿é—´éš”
            lastReconnectAttempt = now;
            connect();
        }
    }
    
    void sendStatus(float currentTemp, float targetTemp, bool heating, bool manual) {
        if(!mqttConnected) return;
        
        DynamicJsonDocument doc(512);
        doc["deviceId"] = deviceId;
        doc["currentTemp"] = round(currentTemp * 10) / 10.0;  // ä¿ç•™1ä½å°æ•°
        doc["targetTemp"] = round(targetTemp * 10) / 10.0;
        doc["heatingStatus"] = heating;
        doc["manualMode"] = manual;
        doc["timestamp"] = millis();
        doc["rssi"] = WiFi.RSSI();
        doc["freeHeap"] = ESP.getFreeHeap();
        
        String output;
        serializeJson(doc, output);
        
        String topic = "smart-home/" + deviceId + "/status";
        mqttClient.publish(topic.c_str(), output.c_str(), true);  // ä¿ç•™æ¶ˆæ¯
    }
    
    void sendHeartbeat() {
        unsigned long now = millis();
        if(now - lastHeartbeat > 30000) {  // 30ç§’å¿ƒè·³
            lastHeartbeat = now;
            
            if(mqttConnected) {
                DynamicJsonDocument doc(256);
                doc["deviceId"] = deviceId;
                doc["timestamp"] = now;
                doc["uptime"] = now;
                doc["rssi"] = WiFi.RSSI();
                doc["freeHeap"] = ESP.getFreeHeap();
                
                String output;
                serializeJson(doc, output);
                
                String topic = "smart-home/" + deviceId + "/heartbeat";
                mqttClient.publish(topic.c_str(), output.c_str());
            }
        }
    }
    
    void publishAlert(String alertType, String message) {
        if(!mqttConnected) return;
        
        DynamicJsonDocument doc(512);
        doc["deviceId"] = deviceId;
        doc["alertType"] = alertType;
        doc["message"] = message;
        doc["timestamp"] = millis();
        doc["severity"] = getSeverityLevel(alertType);
        
        String output;
        serializeJson(doc, output);
        
        String topic = "smart-home/" + deviceId + "/alert";
        mqttClient.publish(topic.c_str(), output.c_str());
        
        Serial.printf("ğŸš¨ å‘é€æŠ¥è­¦: %s - %s\n", alertType.c_str(), message.c_str());
    }
    
    void publishOnlineStatus(bool online) {
        if(!mqttConnected) return;
        
        String topic = "smart-home/" + deviceId + "/online";
        mqttClient.publish(topic.c_str(), online ? "true" : "false", true);
    }
    
    bool isConnected() {
        return mqttConnected && mqttClient.connected();
    }
    
private:
    void onMqttMessage(char* topic, byte* payload, unsigned int length) {
        String message;
        for(unsigned int i = 0; i < length; i++) {
            message += (char)payload[i];
        }
        
        Serial.printf("ğŸ“¨ æ”¶åˆ°MQTTæ¶ˆæ¯: %s = %s\n", topic, message.c_str());
        
        // è§£æJSONå‘½ä»¤
        DynamicJsonDocument doc(1024);
        DeserializationError error = deserializeJson(doc, message);
        
        if(error) {
            Serial.printf("âŒ JSONè§£æé”™è¯¯: %s\n", error.c_str());
            return;
        }
        
        // å¤„ç†ä¸åŒçš„å‘½ä»¤
        handleRemoteCommand(doc);
    }
    
    void handleRemoteCommand(JsonDocument& doc) {
        // è¿™é‡Œéœ€è¦å¤–éƒ¨å¤„ç†å™¨æ¥å®é™…æ‰§è¡Œå‘½ä»¤
        // å¯ä»¥é€šè¿‡å›è°ƒå‡½æ•°æˆ–å…¨å±€å˜é‡æ¥å®ç°
        
        if(doc.containsKey("targetTemp")) {
            float newTarget = doc["targetTemp"];
            // é€šçŸ¥ä¸»ç¨‹åºæ›´æ–°ç›®æ ‡æ¸©åº¦
            Serial.printf("ğŸ¯ è¿œç¨‹è®¾ç½®ç›®æ ‡æ¸©åº¦: %.1fÂ°C\n", newTarget);
        }
        
        if(doc.containsKey("manualMode")) {
            bool manual = doc["manualMode"];
            Serial.printf("ğŸ”§ è¿œç¨‹åˆ‡æ¢æ¨¡å¼: %s\n", manual ? "æ‰‹åŠ¨" : "è‡ªåŠ¨");
        }
        
        if(doc.containsKey("heating") && doc.containsKey("manualMode") && doc["manualMode"]) {
            bool heating = doc["heating"];
            Serial.printf("ğŸ”¥ è¿œç¨‹æ‰‹åŠ¨æ§åˆ¶: %s\n", heating ? "å¼€å¯åŠ çƒ­" : "å…³é—­åŠ çƒ­");
        }
        
        if(doc.containsKey("reboot") && doc["reboot"]) {
            Serial.println("ğŸ”„ è¿œç¨‹é‡å¯å‘½ä»¤");
            delay(1000);
            ESP.restart();
        }
    }
    
    String getSeverityLevel(String alertType) {
        if(alertType == "overheat" || alertType == "sensor_error") {
            return "high";
        } else if(alertType == "connection_lost" || alertType == "heating_timeout") {
            return "medium";
        } else {
            return "low";
        }
    }
};

// ========================= DisplayManager å®ç° =========================
class DisplayManager {
private:
    SSD1306Wire* display;
    bool displayEnabled;
    unsigned long lastUpdate;
    int currentPage;
    bool displayOn;
    
public:
    DisplayManager(int sda, int scl) {
        display = new SSD1306Wire(0x3c, sda, scl);
        displayEnabled = false;
        lastUpdate = 0;
        currentPage = 0;
        displayOn = true;
    }
    
    void init() {
        display->init();
        display->flipScreenVertically();
        display->setFont(ArialMT_Plain_10);
        
        // æ˜¾ç¤ºå¯åŠ¨ç”»é¢
        display->clear();
        display->setTextAlignment(TEXT_ALIGN_CENTER);
        display->setFont(ArialMT_Plain_16);
        display->drawString(64, 20, "æ™ºèƒ½åœ°æš–");
        display->setFont(ArialMT_Plain_10);
        display->drawString(64, 40, "ç³»ç»Ÿå¯åŠ¨ä¸­...");
        display->display();
        
        displayEnabled = true;
        Serial.println("ğŸ“º OLEDæ˜¾ç¤ºå±å·²åˆå§‹åŒ–");
    }
    
    void updateDisplay(float currentTemp, float targetTemp, bool heating, bool connected) {
        if(!displayEnabled || !displayOn) return;
        
        unsigned long now = millis();
        if(now - lastUpdate < 1000) return;  // 1ç§’æ›´æ–°ä¸€æ¬¡
        lastUpdate = now;
        
        display->clear();
        
        switch(currentPage) {
            case 0:
                drawMainPage(currentTemp, targetTemp, heating, connected);
                break;
            case 1:
                drawStatusPage(connected);
                break;
            case 2:
                drawSystemPage();
                break;
        }
        
        display->display();
    }
    
    void drawMainPage(float currentTemp, float targetTemp, bool heating, bool connected) {
        // è¿æ¥çŠ¶æ€å›¾æ ‡
        if(connected) {
            display->setPixel(120, 2);
            display->setPixel(121, 1);
            display->setPixel(122, 0);
            display->setPixel(123, 1);
            display->setPixel(124, 2);
        } else {
            display->drawString(110, 0, "âŒ");
        }
        
        // å½“å‰æ¸©åº¦ (å¤§å­—ä½“)
        display->setFont(ArialMT_Plain_24);
        display->setTextAlignment(TEXT_ALIGN_CENTER);
        String tempStr = String(currentTemp, 1) + "Â°C";
        display->drawString(64, 15, tempStr);
        
        // ç›®æ ‡æ¸©åº¦
        display->setFont(ArialMT_Plain_10);
        display->setTextAlignment(TEXT_ALIGN_LEFT);
        display->drawString(0, 45, "ç›®æ ‡: " + String(targetTemp, 1) + "Â°C");
        
        // åŠ çƒ­çŠ¶æ€
        display->setTextAlignment(TEXT_ALIGN_RIGHT);
        if(heating) {
            display->drawString(128, 45, "ğŸ”¥ åŠ çƒ­ä¸­");
        } else {
            display->drawString(128, 45, "â„ï¸ å¾…æœº");
        }
        
        // é¡µé¢æŒ‡ç¤ºå™¨
        drawPageIndicator();
    }
    
    void drawStatusPage(bool connected) {
        display->setFont(ArialMT_Plain_10);
        display->setTextAlignment(TEXT_ALIGN_LEFT);
        
        display->drawString(0, 0, "ç³»ç»ŸçŠ¶æ€");
        display->drawString(0, 15, "WiFi: " + (connected ? "å·²è¿æ¥" : "æœªè¿æ¥"));
        display->drawString(0, 25, "RSSI: " + String(WiFi.RSSI()) + " dBm");
        display->drawString(0, 35, "å†…å­˜: " + String(ESP.getFreeHeap()) + " B");
        display->drawString(0, 45, "è¿è¡Œ: " + String(millis() / 1000) + " ç§’");
        
        drawPageIndicator();
    }
    
    void drawSystemPage() {
        display->setFont(ArialMT_Plain_10);
        display->setTextAlignment(TEXT_ALIGN_LEFT);
        
        display->drawString(0, 0, "è®¾å¤‡ä¿¡æ¯");
        display->drawString(0, 15, "èŠ¯ç‰‡: ESP8266");
        display->drawString(0, 25, "é¢‘ç‡: " + String(ESP.getCpuFreqMHz()) + " MHz");
        display->drawString(0, 35, "Flash: " + String(ESP.getFlashChipSize()) + " B");
        display->drawString(0, 45, "ç‰ˆæœ¬: v1.0.0");
        
        drawPageIndicator();
    }
    
    void drawPageIndicator() {
        // åœ¨åº•éƒ¨ç»˜åˆ¶é¡µé¢æŒ‡ç¤ºå™¨
        int totalPages = 3;
        int indicatorWidth = 6;
        int spacing = 2;
        int startX = 64 - (totalPages * indicatorWidth + (totalPages - 1) * spacing) / 2;
        
        for(int i = 0; i < totalPages; i++) {
            int x = startX + i * (indicatorWidth + spacing);
            if(i == currentPage) {
                display->fillRect(x, 58, indicatorWidth, 4);
            } else {
                display->drawRect(x, 58, indicatorWidth, 4);
            }
        }
    }
    
    void nextPage() {
        currentPage = (currentPage + 1) % 3;
    }
    
    void showWiFiConnecting() {
        if(!displayEnabled) return;
        
        display->clear();
        display->setFont(ArialMT_Plain_10);
        display->setTextAlignment(TEXT_ALIGN_CENTER);
        display->drawString(64, 20, "è¿æ¥WiFiä¸­...");
        
        // æ˜¾ç¤ºåŠ¨ç”»ç‚¹
        int dots = (millis() / 500) % 4;
        String dotStr = "";
        for(int i = 0; i < dots; i++) {
            dotStr += ".";
        }
        display->drawString(64, 35, dotStr);
        
        display->display();
    }
    
    void showError(String error) {
        if(!displayEnabled) return;
        
        display->clear();
        display->setFont(ArialMT_Plain_10);
        display->setTextAlignment(TEXT_ALIGN_CENTER);
        display->drawString(64, 15, "âŒ é”™è¯¯");
        display->drawString(64, 30, error);
        display->display();
    }
    
    void setBrightness(int level) {
        // ESP8266çš„SSD1306åº“å¯èƒ½ä¸æ”¯æŒäº®åº¦è°ƒèŠ‚
        // å¯ä»¥é€šè¿‡PWMæ§åˆ¶èƒŒå…‰æˆ–ä½¿ç”¨å…¶ä»–æ–¹æ³•
    }
    
    void turnOff() {
        if(displayEnabled) {
            display->displayOff();
            displayOn = false;
        }
    }
    
    void turnOn() {
        if(displayEnabled) {
            display->displayOn();
            displayOn = true;
        }
    }
};

// ========================= RF433Manager å®ç° =========================
class RF433Manager {
private:
    RCSwitch transmitter;
    RCSwitch receiver;
    int txPin;
    int rxPin;
    unsigned long lastSignal;
    unsigned long heatingOnCode;
    unsigned long heatingOffCode;
    
public:
    RF433Manager(int tx, int rx) {
        txPin = tx;
        rxPin = rx;
        lastSignal = 0;
        heatingOnCode = 5393;   // ç¤ºä¾‹ä»£ç ï¼Œéœ€è¦æ ¹æ®å®é™…è®¾å¤‡è°ƒæ•´
        heatingOffCode = 5396;  // ç¤ºä¾‹ä»£ç ï¼Œéœ€è¦æ ¹æ®å®é™…è®¾å¤‡è°ƒæ•´
    }
    
    void init() {
        transmitter.enableTransmit(txPin);
        transmitter.setPulseLength(350);
        transmitter.setProtocol(1);
        transmitter.setRepeatTransmit(5);
        
        receiver.enableReceive(digitalPinToInterrupt(rxPin));
        
        Serial.printf("ğŸ“¡ 433MHzæ¨¡å—å·²åˆå§‹åŒ– (TX: %d, RX: %d)\n", txPin, rxPin);
    }
    
    void sendCommand(unsigned long code) {
        transmitter.send(code, 24);
        Serial.printf("ğŸ“¤ å‘é€433MHzä¿¡å·: %lu\n", code);
        delay(100);  // é¿å…ä¿¡å·å†²çª
    }
    
    bool receiveCommand(unsigned long& code) {
        if(receiver.available()) {
            code = receiver.getReceivedValue();
            receiver.resetAvailable();
            
            if(code != 0 && isSignalValid(code)) {
                lastSignal = millis();
                Serial.printf("ğŸ“¥ æ¥æ”¶433MHzä¿¡å·: %lu\n", code);
                return true;
            }
        }
        return false;
    }
    
    void sendHeatingOn() {
        sendCommand(heatingOnCode);
        Serial.println("ğŸ”¥ å‘é€åŠ çƒ­å¼€å¯ä¿¡å·");
    }
    
    void sendHeatingOff() {
        sendCommand(heatingOffCode);
        Serial.println("â„ï¸ å‘é€åŠ çƒ­å…³é—­ä¿¡å·");
    }
    
    bool isSignalValid(unsigned long code) {
        // éªŒè¯ä¿¡å·æ˜¯å¦ä¸ºå·²çŸ¥çš„æœ‰æ•ˆä¿¡å·
        unsigned long validCodes[] = {heatingOnCode, heatingOffCode, 1234, 5678};  // æ·»åŠ æ›´å¤šæœ‰æ•ˆä»£ç 
        int numCodes = sizeof(validCodes) / sizeof(validCodes[0]);
        
        for(int i = 0; i < numCodes; i++) {
            if(code == validCodes[i]) {
                return true;
            }
        }
        return false;
    }
    
    void setHeatingCodes(unsigned long onCode, unsigned long offCode) {
        heatingOnCode = onCode;
        heatingOffCode = offCode;
        Serial.printf("ğŸ”§ è®¾ç½®åŠ çƒ­æ§åˆ¶ä»£ç : ON=%lu, OFF=%lu\n", onCode, offCode);
    }
    
    unsigned long getLastSignalTime() {
        return lastSignal;
    }
};

// ========================= SecurityMonitor å®ç° =========================
class SecurityMonitor {
private:
    float maxTemp;
    float minTemp;
    unsigned long maxHeatingTime;
    unsigned long heatingStartTime;
    unsigned long lastTempCheck;
    bool overheating;
    bool sensorError;
    bool heatingTimeout;
    String lastAlert;
    
public:
    SecurityMonitor() {
        maxTemp = 35.0;        // æœ€é«˜æ¸©åº¦é™åˆ¶
        minTemp = 5.0;         // æœ€ä½æ¸©åº¦é™åˆ¶
        maxHeatingTime = 7200000;  // 2å°æ—¶æœ€å¤§è¿ç»­åŠ çƒ­æ—¶é—´
        heatingStartTime = 0;
        lastTempCheck = 0;
        overheating = false;
        sensorError = false;
        heatingTimeout = false;
        lastAlert = "";
    }
    
    void checkTemperatureLimits(float temp) {
        unsigned long now = millis();
        
        // æ£€æŸ¥æ¸©åº¦è¿‡é«˜
        if(temp > maxTemp) {
            if(!overheating) {
                overheating = true;
                lastAlert = "æ¸©åº¦è¿‡é«˜: " + String(temp, 1) + "Â°C";
                Serial.printf("ğŸš¨ %s\n", lastAlert.c_str());
            }
        } else {
            overheating = false;
        }
        
        // æ£€æŸ¥æ¸©åº¦è¿‡ä½ï¼ˆå¯èƒ½çš„ä¼ æ„Ÿå™¨æ•…éšœï¼‰
        if(temp < minTemp) {
            if(!sensorError) {
                sensorError = true;
                lastAlert = "æ¸©åº¦å¼‚å¸¸: " + String(temp, 1) + "Â°C";
                Serial.printf("ğŸš¨ %s\n", lastAlert.c_str());
            }
        } else if(temp > minTemp + 2) {  // æœ‰ä¸€å®šå®¹å·®
            sensorError = false;
        }
        
        lastTempCheck = now;
    }
    
    void checkHeatingDuration(bool heating) {
        unsigned long now = millis();
        
        if(heating) {
            if(heatingStartTime == 0) {
                heatingStartTime = now;
            } else if(now - heatingStartTime > maxHeatingTime) {
                if(!heatingTimeout) {
                    heatingTimeout = true;
                    lastAlert = "åŠ çƒ­è¶…æ—¶: " + String((now - heatingStartTime) / 60000) + "åˆ†é’Ÿ";
                    Serial.printf("ğŸš¨ %s\n", lastAlert.c_str());
                }
            }
        } else {
            heatingStartTime = 0;
            heatingTimeout = false;
        }
    }
    
    void checkSensorHealth(float temp) {
        unsigned long now = millis();
        
        // æ£€æŸ¥æ¸©åº¦è¯»å–æ˜¯å¦æ­£å¸¸
        if(now - lastTempCheck > 60000) {  // è¶…è¿‡1åˆ†é’Ÿæ²¡æœ‰æ¸©åº¦æ›´æ–°
            if(!sensorError) {
                sensorError = true;
                lastAlert = "ä¼ æ„Ÿå™¨æ— å“åº”";
                Serial.printf("ğŸš¨ %s\n", lastAlert.c_str());
            }
        }
        
        // æ£€æŸ¥æ¸©åº¦å€¼æ˜¯å¦åˆç†
        if(temp == -127.0 || temp == 85.0) {  // DS18B20çš„é”™è¯¯å€¼
            if(!sensorError) {
                sensorError = true;
                lastAlert = "ä¼ æ„Ÿå™¨è¯»å–é”™è¯¯";
                Serial.printf("ğŸš¨ %s\n", lastAlert.c_str());
            }
        }
    }
    
    bool hasAlerts() {
        return overheating || sensorError || heatingTimeout;
    }
    
    String getAlertMessage() {
        if(overheating) return "æ¸©åº¦è¿‡é«˜";
        if(sensorError) return "ä¼ æ„Ÿå™¨æ•…éšœ";
        if(heatingTimeout) return "åŠ çƒ­è¶…æ—¶";
        return "";
    }
    
    String getDetailedAlert() {
        return lastAlert;
    }
    
    void resetAlerts() {
        overheating = false;
        sensorError = false;
        heatingTimeout = false;
        lastAlert = "";
    }
    
    bool isOverheating() { return overheating; }
    bool isSensorError() { return sensorError; }
    bool isHeatingTimeout() { return heatingTimeout; }
    
    void setTemperatureLimits(float min, float max) {
        minTemp = min;
        maxTemp = max;
        Serial.printf("ğŸ”§ è®¾ç½®æ¸©åº¦é™åˆ¶: %.1fÂ°C ~ %.1fÂ°C\n", min, max);
    }
    
    void setMaxHeatingTime(unsigned long minutes) {
        maxHeatingTime = minutes * 60000;
        Serial.printf("ğŸ”§ è®¾ç½®æœ€å¤§åŠ çƒ­æ—¶é—´: %luåˆ†é’Ÿ\n", minutes);
    }
    
    unsigned long getHeatingDuration() {
        if(heatingStartTime == 0) return 0;
        return (millis() - heatingStartTime) / 60000;  // è¿”å›åˆ†é’Ÿæ•°
    }
};

// ========================= ConfigManager å®ç° =========================
class ConfigManager {
private:
    struct Config {
        char wifiSSID[32];
        char wifiPassword[64];
        char mqttServer[64];
        int mqttPort;
        float defaultTargetTemp;
        float tempTolerance;
        int updateInterval;
        unsigned long maxHeatingTime;
        float maxTemp;
        float minTemp;
        char deviceId[16];
        uint32_t checksum;
    };
    
    Config config;
    bool configLoaded;
    
public:
    ConfigManager() {
        configLoaded = false;
        setDefaults();
    }
    
    void setDefaults() {
        strcpy(config.wifiSSID, "");
        strcpy(config.wifiPassword, "");
        strcpy(config.mqttServer, "mqtt.example.com");
        config.mqttPort = 1883;
        config.defaultTargetTemp = 22.0;
        config.tempTolerance = 0.5;
        config.updateInterval = 30;
        config.maxHeatingTime = 120;  // åˆ†é’Ÿ
        config.maxTemp = 35.0;
        config.minTemp = 5.0;
        
        // ç”Ÿæˆè®¾å¤‡ID
        String chipId = String(ESP.getChipId(), HEX);
        strcpy(config.deviceId, chipId.c_str());
        
        config.checksum = calculateChecksum();
    }
    
    void loadFromEEPROM() {
        EEPROM.begin(512);
        
        EEPROM.get(0, config);
        
        if(config.checksum == calculateChecksum()) {
            configLoaded = true;
            Serial.println("âœ… ä»EEPROMåŠ è½½é…ç½®æˆåŠŸ");
        } else {
            Serial.println("âŒ EEPROMé…ç½®æ ¡éªŒå¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤é…ç½®");
            setDefaults();
            saveToEEPROM();
        }
        
        EEPROM.end();
    }
    
    void saveToEEPROM() {
        config.checksum = calculateChecksum();
        
        EEPROM.begin(512);
        EEPROM.put(0, config);
        EEPROM.commit();
        EEPROM.end();
        
        Serial.println("ğŸ’¾ é…ç½®å·²ä¿å­˜åˆ°EEPROM");
    }
    
    uint32_t calculateChecksum() {
        uint32_t checksum = 0;
        uint8_t* data = (uint8_t*)&config;
        int size = sizeof(Config) - sizeof(uint32_t);  // ä¸åŒ…æ‹¬checksumå­—æ®µ
        
        for(int i = 0; i < size; i++) {
            checksum += data[i];
        }
        return checksum;
    }
    
    // WiFi é…ç½®
    void setWiFiCredentials(String ssid, String password) {
        strncpy(config.wifiSSID, ssid.c_str(), sizeof(config.wifiSSID) - 1);
        strncpy(config.wifiPassword, password.c_str(), sizeof(config.wifiPassword) - 1);
        config.wifiSSID[sizeof(config.wifiSSID) - 1] = '\0';
        config.wifiPassword[sizeof(config.wifiPassword) - 1] = '\0';
    }
    
    String getWiFiSSID() { return String(config.wifiSSID); }
    String getWiFiPassword() { return String(config.wifiPassword); }
    
    // MQTT é…ç½®
    void setMQTTServer(String server, int port = 1883) {
        strncpy(config.mqttServer, server.c_str(), sizeof(config.mqttServer) - 1);
        config.mqttServer[sizeof(config.mqttServer) - 1] = '\0';
        config.mqttPort = port;
    }
    
    String getMQTTServer() { return String(config.mqttServer); }
    int getMQTTPort() { return config.mqttPort; }
    
    // æ¸©åº¦é…ç½®
    void setTemperatureSettings(float target, float tolerance) {
        config.defaultTargetTemp = target;
        config.tempTolerance = tolerance;
    }
    
    float getDefaultTargetTemp() { return config.defaultTargetTemp; }
    float getTempTolerance() { return config.tempTolerance; }
    
    // å…¶ä»–é…ç½®
    int getUpdateInterval() { return config.updateInterval; }
    void setUpdateInterval(int interval) { config.updateInterval = interval; }
    
    unsigned long getMaxHeatingTime() { return config.maxHeatingTime; }
    void setMaxHeatingTime(unsigned long minutes) { config.maxHeatingTime = minutes; }
    
    float getMaxTemp() { return config.maxTemp; }
    float getMinTemp() { return config.minTemp; }
    void setTemperatureLimits(float min, float max) {
        config.minTemp = min;
        config.maxTemp = max;
    }
    
    String getDeviceId() { return String(config.deviceId); }
    
    // æ‰“å°é…ç½®ä¿¡æ¯
    void printConfig() {
        Serial.println("ğŸ“‹ å½“å‰é…ç½®:");
        Serial.printf("  è®¾å¤‡ID: %s\n", config.deviceId);
        Serial.printf("  WiFi SSID: %s\n", config.wifiSSID);
        Serial.printf("  MQTTæœåŠ¡å™¨: %s:%d\n", config.mqttServer, config.mqttPort);
        Serial.printf("  é»˜è®¤ç›®æ ‡æ¸©åº¦: %.1fÂ°C\n", config.defaultTargetTemp);
        Serial.printf("  æ¸©åº¦å®¹å·®: %.1fÂ°C\n", config.tempTolerance);
        Serial.printf("  æ›´æ–°é—´éš”: %dç§’\n", config.updateInterval);
        Serial.printf("  æœ€å¤§åŠ çƒ­æ—¶é—´: %luåˆ†é’Ÿ\n", config.maxHeatingTime);
        Serial.printf("  æ¸©åº¦é™åˆ¶: %.1fÂ°C ~ %.1fÂ°C\n", config.minTemp, config.maxTemp);
    }
    
    bool isConfigLoaded() { return configLoaded; }
};
```
## ğŸš€ éƒ¨ç½²æŒ‡å—

### 1. ç¡¬ä»¶ç»„è£…

```mermaid
graph LR
    A[220Vç”µæº] --> B[AC-DCæ¨¡å—]
    B --> C[ESP8266]
    B --> D[ç»§ç”µå™¨æ¨¡å—]
    C --> E[æ¸©åº¦ä¼ æ„Ÿå™¨]
    C --> F[433MHzæ¨¡å—]
    C --> G[OLEDæ˜¾ç¤º]
    D --> H[åœ°æš–æ§åˆ¶]
```

**å®‰å…¨æ³¨æ„äº‹é¡¹ï¼š**
- âš ï¸ 220V äº¤æµç”µæ“ä½œéœ€è¦ä¸“ä¸šç”µå·¥
- ğŸ”Œ ç¡®ä¿è‰¯å¥½æ¥åœ°å’Œç»ç¼˜
- ğŸ  å®‰è£…åœ¨å¹²ç‡¥é€šé£ä½ç½®
- ğŸ›¡ï¸ ä½¿ç”¨åˆé€‚çš„é˜²æŠ¤å¤–å£³

### 2. è½¯ä»¶éƒ¨ç½²

**ESP8266 å›ºä»¶çƒ§å½•ï¼š**
```bash
# 1. å®‰è£… Arduino IDE
# 2. é…ç½®å¼€å‘æ¿å’Œåº“
# 3. ç¼–è¯‘å¹¶ä¸Šä¼ ä»£ç åˆ° ESP8266
# 4. é€šè¿‡ä¸²å£ç›‘è§†å™¨æŸ¥çœ‹è¿è¡ŒçŠ¶æ€
```

**æœåŠ¡å™¨éƒ¨ç½²ï¼š**
```bash
# å…‹éš†é¡¹ç›®
git clone <your-repo-url>
cd smart-home-server

# å®‰è£…ä¾èµ–
npm install

# é…ç½®ç¯å¢ƒå˜é‡
cp .env.example .env
# ç¼–è¾‘ .env æ–‡ä»¶

# åˆ›å»ºæ•°æ®åº“
mysql -u root -p < database/schema.sql

# å¯åŠ¨æœåŠ¡
npm start

# æˆ–ä½¿ç”¨ PM2 è¿›è¡Œç”Ÿäº§éƒ¨ç½²
npm install -g pm2
pm2 start src/app.js --name smart-home
```

### 3. ç½‘ç»œé…ç½®

**è·¯ç”±å™¨è®¾ç½®ï¼š**
- ä¸º ESP8266 åˆ†é…å›ºå®š IP
- å¼€æ”¾å¿…è¦çš„ç«¯å£ï¼ˆå¦‚ 3000, 1883ï¼‰
- é…ç½®ç«¯å£è½¬å‘ï¼ˆå¦‚éœ€å¤–ç½‘è®¿é—®ï¼‰

**MQTT æœåŠ¡å™¨ï¼š**
```bash
# å®‰è£… Mosquitto MQTT Broker
sudo apt install mosquitto mosquitto-clients

# å¯åŠ¨æœåŠ¡
sudo systemctl start mosquitto
sudo systemctl enable mosquitto

# æµ‹è¯•è¿æ¥
mosquitto_pub -h localhost -t test -m "Hello MQTT"
```

## ğŸ“Š æµ‹è¯•ä¸è°ƒè¯•

### 1. ç¡¬ä»¶æµ‹è¯•

```cpp
// æµ‹è¯•ä»£ç ç‰‡æ®µ
void testHardware() {
  // æµ‹è¯•æ¸©åº¦ä¼ æ„Ÿå™¨
  sensors.requestTemperatures();
  float temp = sensors.getTempCByIndex(0);
  Serial.printf("æ¸©åº¦ä¼ æ„Ÿå™¨è¯»æ•°: %.2fÂ°C\n", temp);
  
  // æµ‹è¯•ç»§ç”µå™¨
  digitalWrite(RELAY_PIN, HIGH);
  delay(1000);
  digitalWrite(RELAY_PIN, LOW);
  
  // æµ‹è¯• 433MHz æ¨¡å—
  // å‘é€æµ‹è¯•ä¿¡å·
  
  // æµ‹è¯• OLED æ˜¾ç¤º
  // æ˜¾ç¤ºæµ‹è¯•ä¿¡æ¯
}
```

### 2. é€šä¿¡æµ‹è¯•

```bash
# æµ‹è¯• MQTT é€šä¿¡
mosquitto_sub -h localhost -t "smart-home/temperature/+"

# å‘é€æ§åˆ¶å‘½ä»¤
mosquitto_pub -h localhost -t "smart-home/temperature/control" -m '{"targetTemp":25.0}'
```

### 3. API æµ‹è¯•

```bash
# æµ‹è¯•è®¾å¤‡çŠ¶æ€ API
curl http://localhost:3000/api/status

# æµ‹è¯•æ§åˆ¶ API
curl -X POST http://localhost:3000/api/control \
  -H "Content-Type: application/json" \
  -d '{"targetTemp": 24.0}'

# æµ‹è¯•å†å²æ•°æ® API
curl http://localhost:3000/api/history?limit=10
```

## ğŸ“± ç§»åŠ¨ç«¯å¼€å‘

### Flutter åº”ç”¨ç¤ºä¾‹

```dart
// lib/main.dart
import 'package:flutter/material.dart';
import 'package:socket_io_client/socket_io_client.dart' as IO;

void main() {
  runApp(SmartHomeApp());
}

class SmartHomeApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'æ™ºèƒ½åœ°æš–æ§åˆ¶',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        visualDensity: VisualDensity.adaptivePlatformDensity,
      ),
      home: HomePage(),
    );
  }
}

class HomePage extends StatefulWidget {
  @override
  _HomePageState createState() => _HomePageState();
}

class _HomePageState extends State<HomePage> {
  late IO.Socket socket;
  double currentTemp = 0.0;
  double targetTemp = 22.0;
  bool heatingStatus = false;
  bool manualMode = false;
  bool isConnected = false;

  @override
  void initState() {
    super.initState();
    initSocket();
  }

  void initSocket() {
    socket = IO.io('http://your-server.com:3000', <String, dynamic>{
      'transports': ['websocket'],
      'autoConnect': false,
    });

    socket.connect();

    socket.on('connect', (_) {
      print('è¿æ¥åˆ°æœåŠ¡å™¨');
      setState(() {
        isConnected = true;
      });
    });

    socket.on('disconnect', (_) {
      print('ä¸æœåŠ¡å™¨æ–­å¼€è¿æ¥');
      setState(() {
        isConnected = false;
      });
    });

    socket.on('deviceStatus', (data) {
      setState(() {
        currentTemp = data['currentTemp'].toDouble();
        targetTemp = data['targetTemp'].toDouble();
        heatingStatus = data['heatingStatus'];
        manualMode = data['manualMode'];
      });
    });
  }

  void setTargetTemp(double temp) {
    socket.emit('setTargetTemp', temp);
  }

  void toggleMode() {
    socket.emit('setMode', !manualMode);
  }

  void manualControl(bool heating) {
    socket.emit('manualControl', heating);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('æ™ºèƒ½åœ°æš–æ§åˆ¶'),
        backgroundColor: Colors.blue[600],
        actions: [
          Icon(
            isConnected ? Icons.wifi : Icons.wifi_off,
            color: isConnected ? Colors.green : Colors.red,
          ),
          SizedBox(width: 16),
        ],
      ),
      body: Container(
        decoration: BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [Colors.blue[400]!, Colors.blue[600]!],
          ),
        ),
        child: SafeArea(
          child: Padding(
            padding: EdgeInsets.all(16.0),
            child: Column(
              children: [
                // æ¸©åº¦æ˜¾ç¤ºå¡ç‰‡
                Card(
                  elevation: 8,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(16),
                  ),
                  child: Padding(
                    padding: EdgeInsets.all(24.0),
                    child: Column(
                      children: [
                        Text(
                          'å½“å‰æ¸©åº¦',
                          style: TextStyle(
                            fontSize: 18,
                            color: Colors.grey[600],
                          ),
                        ),
                        SizedBox(height: 8),
                        Text(
                          '${currentTemp.toStringAsFixed(1)}Â°C',
                          style: TextStyle(
                            fontSize: 48,
                            fontWeight: FontWeight.bold,
                            color: Colors.blue[700],
                          ),
                        ),
                        SizedBox(height: 16),
                        Row(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            Icon(
                              heatingStatus ? Icons.local_fire_department : Icons.ac_unit,
                              color: heatingStatus ? Colors.orange : Colors.blue,
                            ),
                            SizedBox(width: 8),
                            Text(
                              heatingStatus ? 'æ­£åœ¨åŠ çƒ­' : 'å¾…æœºä¸­',
                              style: TextStyle(
                                fontSize: 16,
                                color: heatingStatus ? Colors.orange : Colors.blue,
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                ),
                
                SizedBox(height: 20),
                
                // æ¸©åº¦æ§åˆ¶å¡ç‰‡
                Card(
                  elevation: 8,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(16),
                  ),
                  child: Padding(
                    padding: EdgeInsets.all(24.0),
                    child: Column(
                      children: [
                        Text(
                          'ç›®æ ‡æ¸©åº¦',
                          style: TextStyle(
                            fontSize: 18,
                            color: Colors.grey[600],
                          ),
                        ),
                        SizedBox(height: 16),
                        Row(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            IconButton(
                              onPressed: () {
                                if (targetTemp > 5) {
                                  setTargetTemp(targetTemp - 0.5);
                                }
                              },
                              icon: Icon(Icons.remove_circle),
                              iconSize: 40,
                              color: Colors.blue[600],
                            ),
                            SizedBox(width: 20),
                            Text(
                              '${targetTemp.toStringAsFixed(1)}Â°C',
                              style: TextStyle(
                                fontSize: 32,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                            SizedBox(width: 20),
                            IconButton(
                              onPressed: () {
                                if (targetTemp < 35) {
                                  setTargetTemp(targetTemp + 0.5);
                                }
                              },
                              icon: Icon(Icons.add_circle),
                              iconSize: 40,
                              color: Colors.blue[600],
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                ),
                
                SizedBox(height: 20),
                
                // æ§åˆ¶æ¨¡å¼å¡ç‰‡
                Card(
                  elevation: 8,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(16),
                  ),
                  child: Padding(
                    padding: EdgeInsets.all(24.0),
                    child: Column(
                      children: [
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Text(
                              'æ§åˆ¶æ¨¡å¼',
                              style: TextStyle(
                                fontSize: 18,
                                color: Colors.grey[600],
                              ),
                            ),
                            Switch(
                              value: manualMode,
                              onChanged: (value) {
                                toggleMode();
                              },
                              activeColor: Colors.orange,
                            ),
                          ],
                        ),
                        SizedBox(height: 8),
                        Text(
                          manualMode ? 'æ‰‹åŠ¨æ¨¡å¼' : 'è‡ªåŠ¨æ¨¡å¼',
                          style: TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.bold,
                            color: manualMode ? Colors.orange : Colors.green,
                          ),
                        ),
                        
                        if (manualMode) ...[
                          SizedBox(height: 20),
                          Row(
                            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                            children: [
                              ElevatedButton.icon(
                                onPressed: () => manualControl(true),
                                icon: Icon(Icons.local_fire_department),
                                label: Text('å¼€å¯åŠ çƒ­'),
                                style: ElevatedButton.styleFrom(
                                  backgroundColor: Colors.orange,
                                  foregroundColor: Colors.white,
                                ),
                              ),
                              ElevatedButton.icon(
                                onPressed: () => manualControl(false),
                                icon: Icon(Icons.stop),
                                label: Text('å…³é—­åŠ çƒ­'),
                                style: ElevatedButton.styleFrom(
                                  backgroundColor: Colors.grey,
                                  foregroundColor: Colors.white,
                                ),
                              ),
                            ],
                          ),
                        ],
                      ],
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    socket.close();
    super.dispose();
  }
}
```

## ğŸ”§ é«˜çº§åŠŸèƒ½æ‰©å±•

### 1. è¯­éŸ³æ§åˆ¶é›†æˆ

```javascript
// é›†æˆè¯­éŸ³åŠ©æ‰‹ï¼ˆå¦‚å°çˆ±åŒå­¦ã€å¤©çŒ«ç²¾çµï¼‰
const express = require('express');
const app = express();

// å°çˆ±åŒå­¦æŠ€èƒ½æ¥å£
app.post('/xiaoai/webhook', (req, res) => {
  const { intent, slots } = req.body;
  
  switch(intent) {
    case 'SetTemperature':
      const targetTemp = slots.temperature.value;
      // è®¾ç½®æ¸©åº¦é€»è¾‘
      res.json({
        reply: `å·²ä¸ºæ‚¨è®¾ç½®ç›®æ ‡æ¸©åº¦ä¸º${targetTemp}åº¦`
      });
      break;
      
    case 'QueryTemperature':
      // æŸ¥è¯¢å½“å‰æ¸©åº¦
      res.json({
        reply: `å½“å‰å®¤å†…æ¸©åº¦ä¸º${currentTemp}åº¦ï¼Œç›®æ ‡æ¸©åº¦${targetTemp}åº¦`
      });
      break;
  }
});
```

### 2. æœºå™¨å­¦ä¹ ä¼˜åŒ–

```python
# æ¸©åº¦é¢„æµ‹æ¨¡å‹ (Python)
import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split

class TemperaturePredictionModel:
    def __init__(self):
        self.model = RandomForestRegressor(n_estimators=100)
        
    def prepare_features(self, data):
        """å‡†å¤‡ç‰¹å¾æ•°æ®"""
        features = []
        for record in data:
            features.append([
                record['hour'],           # å°æ—¶
                record['day_of_week'],    # æ˜ŸæœŸå‡ 
                record['outdoor_temp'],   # å®¤å¤–æ¸©åº¦
                record['target_temp'],    # ç›®æ ‡æ¸©åº¦
                record['heating_duration'] # åŠ çƒ­æ—¶é•¿
            ])
        return np.array(features)
    
    def train(self, historical_data):
        """è®­ç»ƒæ¨¡å‹"""
        X = self.prepare_features(historical_data);
        y = [record['actual_temp'] for record in historical_data];
        
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2);
        self.model.fit(X_train, y_train);
        
        score = self.model.score(X_test, y_test);
        print(f"æ¨¡å‹å‡†ç¡®ç‡: {score:.2f}");
    
    def predict_optimal_schedule(self, target_temp, outdoor_temp):
        """é¢„æµ‹æœ€ä¼˜åŠ çƒ­è®¡åˆ’"""
        predictions = [];
        for hour in range(24):
            features = [[hour, 1, outdoor_temp, target_temp, 0]];
            predicted_temp = self.model.predict(features)[0];
            predictions.append({
                'hour': hour,
                'predicted_temp': predicted_temp,
                'heating_needed': predicted_temp < target_temp
            });
        return predictions;
  }
  
  calculateEnergySavings(optimizedSchedule, normalSchedule) {
    // è®¡ç®—èŠ‚èƒ½æ•ˆæœ
    let optimizedCost = 0;
    let normalCost = 0;
    
    optimizedSchedule.forEach(slot => {
      const rate = this.getElectricityRate(slot.time);
      optimizedCost += slot.energyConsumption * rate;
    });
    
    normalSchedule.forEach(slot => {
      const rate = this.getElectricityRate(slot.time);
      normalCost += slot.energyConsumption * rate;
    });
    
    return {
      savings: normalCost - optimizedCost,
      percentage: ((normalCost - optimizedCost) / normalCost * 100).toFixed(1)
    };
  }
  
  getElectricityRate(hour) {
    if (this.peakHours.includes(hour)) return 0.8; // å³°æ—¶ç”µä»·
    if (this.lowTariffHours.includes(hour)) return 0.3; // è°·æ—¶ç”µä»·
    return 0.5; // å¹³æ—¶ç”µä»·
  }
}
```

## ğŸ“‹ é¡¹ç›®æ¸…å•

### ğŸ› ï¸ å¿…éœ€ç¡¬ä»¶
- [ ] ESP8266 å¼€å‘æ¿
- [ ] æ¸©åº¦ä¼ æ„Ÿå™¨ (DS18B20)
- [ ] ç»§ç”µå™¨æ¨¡å—
- [ ] AC-DC ç”µæºæ¨¡å—
- [ ] 433MHz æ”¶å‘æ¨¡å—
- [ ] è¿æ¥çº¿æå’Œé¢åŒ…æ¿

### ğŸ’» è½¯ä»¶å¼€å‘
- [ ] ESP8266 å›ºä»¶å¼€å‘
- [ ] Node.js åç«¯æœåŠ¡
- [ ] Web å‰ç«¯ç•Œé¢
- [ ] æ•°æ®åº“è®¾è®¡å’Œåˆ›å»º
- [ ] MQTT æœåŠ¡å™¨é…ç½®

### ğŸ“± å¯é€‰æ‰©å±•
- [ ] ç§»åŠ¨ç«¯ App å¼€å‘
- [ ] OLED æ˜¾ç¤ºå±
- [ ] è¯­éŸ³æ§åˆ¶é›†æˆ
- [ ] æœºå™¨å­¦ä¹ ä¼˜åŒ–
- [ ] èƒ½è€—ç»Ÿè®¡åˆ†æ

### ğŸ”§ éƒ¨ç½²å’Œæµ‹è¯•
- [ ] ç¡¬ä»¶ç»„è£…å’Œè°ƒè¯•
- [ ] è½¯ä»¶éƒ¨ç½²å’Œé…ç½®
- [ ] ç½‘ç»œè¿æ¥æµ‹è¯•
- [ ] åŠŸèƒ½å®Œæ•´æ€§æµ‹è¯•
- [ ] å®‰å…¨æ€§å’Œç¨³å®šæ€§æµ‹è¯•

## ğŸš¨ æ³¨æ„äº‹é¡¹

### âš ï¸ å®‰å…¨æé†’
1. **ç”µæ°”å®‰å…¨**ï¼š220V äº¤æµç”µæ“ä½œéœ€è¦ä¸“ä¸šç”µå·¥
2. **é˜²æ°´é˜²æ½®**ï¼šç¡®ä¿ç”µå­å…ƒä»¶é˜²æŠ¤ç­‰çº§
3. **æ•£çƒ­é€šé£**ï¼šé¿å…å…ƒä»¶è¿‡çƒ­
4. **æ¥åœ°ä¿æŠ¤**ï¼šç¡®ä¿è‰¯å¥½çš„æ¥åœ°è¿æ¥

### ğŸ” ç½‘ç»œå®‰å…¨
1. **å¯†ç å¼ºåº¦**ï¼šä½¿ç”¨å¼ºå¯†ç ä¿æŠ¤è®¾å¤‡
2. **å›ºä»¶æ›´æ–°**ï¼šå®šæœŸæ›´æ–°å›ºä»¶ä¿®å¤æ¼æ´
3. **ç½‘ç»œéš”ç¦»**ï¼šè€ƒè™‘ä½¿ç”¨ IoT ä¸“ç”¨ç½‘ç»œ
4. **æ•°æ®åŠ å¯†**ï¼šæ•æ„Ÿæ•°æ®ä¼ è¾“åŠ å¯†

### ğŸ“Š æ€§èƒ½ä¼˜åŒ–
1. **å“åº”é€Ÿåº¦**ï¼šä¼˜åŒ–ä»£ç å‡å°‘å»¶è¿Ÿ
2. **ç”µæ± ç»­èˆª**ï¼šå¦‚ä½¿ç”¨ç”µæ± ä¾›ç”µéœ€ä¼˜åŒ–åŠŸè€—
3. **ç½‘ç»œç¨³å®š**ï¼šå¤„ç†ç½‘ç»œæ–­çº¿é‡è¿
4. **æ•°æ®å­˜å‚¨**ï¼šåˆç†è®¾è®¡æ•°æ®åº“ç»“æ„

---